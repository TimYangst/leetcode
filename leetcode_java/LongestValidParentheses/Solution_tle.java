package LongestValidParentheses;

public class Solution_tle {
	Boolean[][] f;
	String s;

	public int longestValidParentheses(String s) {
		f = new Boolean[s.length() + 1][];
		this.s = s;
		for (int i = 0; i <= s.length(); i++) {
			f[i] = new Boolean[s.length() + 1];
			for (int j = i + 2; j <= s.length(); j += 2) {
				f[i][j] = null;
			}
		}
		int rst = 0;
		for (int i = 0; i < s.length() - 1; i++) {
			if (s.charAt(i) == ')')
				continue;
			int j = s.length();
			if ((j - i) % 2 == 1)
				j--;
			while (j - i > rst) {
				if (s.charAt(j-1) != '(') {
					search(i, j);
					if (f[i][j] == true) {
						rst = j - i;
						break;
					}
				}
				j -= 2;
			}
		}

		return rst;
	}

	private boolean search(int i, int j) {
		if (f[i][j] != null)
			return f[i][j];
		if (s.charAt(i) == ')' || s.charAt(j - 1) == '(') {
			f[i][j] = false;
			return f[i][j];
		}
		if (i + 2 == j) {
			if (s.charAt(i) == '(' && s.charAt(i + 1) == ')')
				f[i][j] = true;
			else
				f[i][j] = false;
			return f[i][j];
		}
		f[i][j] = false;
		if (s.charAt(i) == '(' && s.charAt(j - 1) == ')') {
			if (search(i + 1, j - 1)) {
				f[i][j] = true;
				return f[i][j];
			}
		}
		for (int u = i + 2; u <= j - 2; u += 2) {
			search(i, u);
			if (f[i][u] == false)
				continue;
			search(u, j);
			if (f[u][j] == false)
				continue;
			f[i][j] = true;
			break;

		}
		return f[i][j];
	}

	public static void main(String[] args) {
		System.out
				.println(new Solution_tle()
						.longestValidParentheses("((())())(()))(()()(()(()))(()((((()))))))((()())()))()()(()(((((()()()())))()())(()()))((((((())))((()))()()))))(()))())))()))()())((()()))))(()(((((())))))()((()(()(())((((())(())((()()(()())))())(()(())()()))())(()()()))()(((()())(((()()())))(((()()()))(()()))()))()))))))())()()((()(())(()))()((()()()((())))()(((()())(()))())())))(((()))))())))()(())))()())))())()((()))((()))()))(((())((()()()(()((()((())))((()()))())(()()(()))))())((())))(()))()))))))()(()))())(()())))))(()))((())(()((())(((((()()()(()()())))(()())()((()(()()))(()(())((()((()))))))))(()(())()())()(()(()(()))()()()(()()())))(())(()((((()()))())))(())((()(())())))))())()()))(((())))())((()(()))(()()))((())(())))))(()(()((()((()()))))))(()()()(()()()(()(())()))()))(((()(())()())(()))())))(((()))())(()((()))(()((()()()(())()(()())()(())(()(()((((())()))(((()()(((()())(()()()(())()())())(()(()()((()))))()(()))))(((())))()()))(()))((()))))()()))))((((()(())()()()((()))((()))())())(()((()()())))))))()))(((()))))))(()())))(((()))((()))())))(((()(((())))())(()))))(((()(((((((((((((())(((()))((((())())()))())((((())(((())))())(((()))))()())()(())())(()))))()))()()()))(((((())()()((()))())(()))()()(()()))(())(()()))()))))(((())))))((()()(()()()()((())((((())())))))((((((()((()((())())(()((()))(()())())())(()(())(())(()((())((())))(())())))(()()())((((()))))((()(())(()(()())))))))))((()())()()))((()(((()((()))(((((()()()()()(()(()((()(()))(()(()((()()))))()(()()((((((()((()())()))((())()()(((((()(()))))()()((()())((()())()(())((()))()()(()))"));
	}
}